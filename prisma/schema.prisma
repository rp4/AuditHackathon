// OpenAuditSwarms - Prisma Schema
// Migrated from tools to swarms (workflow templates)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth.js Tables
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// User & Profile
model User {
  id            String    @id @default(cuid())
  name          String?
  username      String?   @unique // URL-friendly username for profile URLs
  email         String    @unique
  emailVerified DateTime?
  image         String?
  passwordHash  String? // For dev email/password auth
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Soft delete fields
  deletedAt DateTime? // When the user was deleted
  isDeleted Boolean   @default(false) // Flag for soft deletion

  // Admin field
  is_admin Boolean @default(false)

  // Profile fields
  bio              String? @db.Text
  linkedin_url     String?
  linkedin_visible Boolean @default(false) // Whether to show LinkedIn on public profile
  website          String?
  company          String?
  role             String?

  // Relations
  accounts         Account[]
  sessions         Session[]
  swarms           Swarm[]
  favorites        Favorite[]
  ratings          Rating[]
  downloads        Download[]
  comments         Comment[]
  apiUsage         ApiUsage[]
  spendingLimit    UserSpendingLimit?
  copilotSessions  CopilotSession[]
  stepResults      StepResult[]
  auditScores      AuditScore[]
  issueDiscoveries IssueDiscovery[]
  auditReports     AuditReport[]

  @@index([email])
  @@index([username])
  @@index([isDeleted, createdAt])
  @@map("users")
}

// Categories (simplified - no platforms)
model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?  @db.Text
  createdAt   DateTime @default(now())

  swarms Swarm[]

  @@index([slug])
  @@map("categories")
}

// Swarms (workflow templates - formerly tools)
model Swarm {
  id          String @id @default(cuid())
  name        String
  slug        String @unique
  description String @db.Text

  // Workflow fields (replacing documentation)
  workflowNodes    String? @db.Text // JSON array of React Flow nodes
  workflowEdges    String? @db.Text // JSON array of React Flow edges
  workflowMetadata String? @db.Text // JSON object {phase, standard, framework}
  workflowVersion  String  @default("1.0")

  // Media
  image_url String?

  // Metadata
  userId     String
  categoryId String?

  // Status
  is_public   Boolean @default(true)
  is_featured Boolean @default(false)

  // Soft delete fields
  deletedAt DateTime? // When the swarm was deleted
  isDeleted Boolean   @default(false) // Flag for soft deletion

  // Stats (denormalized for performance)
  views_count     Int   @default(0)
  downloads_count Int   @default(0)
  favorites_count Int   @default(0)
  rating_avg      Float @default(0)
  rating_count    Int   @default(0)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  // Relations
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  category    Category?      @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  favorites   Favorite[]
  ratings     Rating[]
  downloads   Download[]
  comments    Comment[]
  versions    SwarmVersion[]
  stepResults StepResult[]

  @@index([slug])
  @@index([userId])
  @@index([categoryId])
  @@index([is_public, publishedAt])
  @@index([rating_avg, rating_count])
  // Composite indexes for common filtered queries
  @@index([userId, isDeleted])
  @@index([categoryId, is_public, isDeleted])
  @@index([isDeleted, publishedAt])
  @@index([isDeleted, views_count])
  @@index([isDeleted, rating_avg])
  @@map("swarms")
}

// User Interactions
model Favorite {
  id        String   @id @default(cuid())
  userId    String
  swarmId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  swarm Swarm @relation(fields: [swarmId], references: [id], onDelete: Cascade)

  @@unique([userId, swarmId])
  @@index([userId])
  @@index([swarmId])
  @@map("favorites")
}

model Rating {
  id        String   @id @default(cuid())
  userId    String
  swarmId   String
  rating    Int // 1-5 stars
  review    String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  swarm Swarm @relation(fields: [swarmId], references: [id], onDelete: Cascade)

  @@unique([userId, swarmId])
  @@index([userId])
  @@index([swarmId])
  @@index([rating])
  @@map("ratings")
}

model Download {
  id        String   @id @default(cuid())
  userId    String
  swarmId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  swarm Swarm @relation(fields: [swarmId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([swarmId])
  @@index([createdAt])
  @@map("downloads")
}

// Comments (threaded)
model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  userId    String
  swarmId   String
  parentId  String? // For nested comments
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  swarm   Swarm     @relation(fields: [swarmId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([userId])
  @@index([swarmId])
  @@index([parentId])
  @@index([createdAt])
  @@map("comments")
}

// Swarm Versions (for tracking changes)
model SwarmVersion {
  id            String   @id @default(cuid())
  swarmId       String
  version       String
  changelog     String?  @db.Text
  configuration Json // Full workflow snapshot
  createdAt     DateTime @default(now())

  swarm Swarm @relation(fields: [swarmId], references: [id], onDelete: Cascade)

  @@index([swarmId])
  @@index([createdAt])
  @@map("swarm_versions")
}

// ============================================
// Copilot Models (for copilot.auditswarm.com)
// ============================================

// API usage tracking for Gemini API calls
model ApiUsage {
  id            String   @id @default(cuid())
  userId        String
  userEmail     String
  model         String
  promptTokens  Int      @default(0)
  outputTokens  Int      @default(0)
  totalTokens   Int      @default(0)
  estimatedCost Float    @default(0)
  sessionId     String?
  createdAt     DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([model])
  @@map("api_usage")
}

// User spending limits for Gemini API usage
model UserSpendingLimit {
  id           String   @id @default(cuid())
  userId       String   @unique
  monthlyLimit Float    @default(5.00)
  updatedBy    String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_spending_limits")
}

// Server-side chat sessions for copilot
model CopilotSession {
  id        String   @id @default(cuid())
  userId    String
  title     String   @default("New Chat")
  model     String   @default("gemini-3-flash-preview")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages CopilotMessage[]

  @@index([userId])
  @@index([updatedAt])
  @@map("copilot_sessions")
}

// Chat messages (server-side persistence)
model CopilotMessage {
  id          String   @id @default(cuid())
  sessionId   String
  role        String // 'user' | 'assistant' | 'system'
  content     String   @db.Text
  attachments String?  @db.Text // JSON array of file attachments
  toolCalls   String?  @db.Text // JSON array of tool call records
  createdAt   DateTime @default(now())

  session CopilotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
  @@map("copilot_messages")
}

// Audit challenge scores — persisted for leaderboard
model AuditScore {
  id        String   @id @default(cuid())
  userId    String
  sessionId String?
  score     Float // 1-10 overall
  details   String   @db.Text // JSON: category breakdown, missed findings, etc.
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([score])
  @@index([createdAt])
  @@map("audit_scores")
}

// ============================================
// Issue Tracking Game Models
// ============================================

// The answer key — known audit issues that users can discover
model AuditIssue {
  id              String   @id @default(cuid())
  issueCode       String   @unique
  title           String
  description     String   @db.Text
  category        String
  severity        String
  financialImpact Float?
  dataSource      String?
  evidence        String?  @db.Text
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  discoveries IssueDiscovery[]

  @@index([category])
  @@index([severity])
  @@index([isActive])
  @@map("audit_issues")
}

// Each report submission to the judge
model AuditReport {
  id            String   @id @default(cuid())
  userId        String
  content       String   @db.Text
  judgeResponse String?  @db.Text
  newIssues     Int      @default(0)
  totalMatched  Int      @default(0)
  sessionId     String?
  createdAt     DateTime @default(now())

  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  discoveries IssueDiscovery[]

  @@index([userId])
  @@index([createdAt])
  @@map("audit_reports")
}

// Per-user per-issue discovery record (idempotent via unique constraint)
model IssueDiscovery {
  id        String   @id @default(cuid())
  userId    String
  issueId   String
  reportId  String
  createdAt DateTime @default(now())

  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  issue  AuditIssue  @relation(fields: [issueId], references: [id], onDelete: Cascade)
  report AuditReport @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@unique([userId, issueId])
  @@index([userId])
  @@index([issueId])
  @@index([reportId])
  @@map("issue_discoveries")
}

// Per-user step results — one result per user per step per workflow (personal workbook)
model StepResult {
  id          String    @id @default(cuid())
  userId      String
  swarmId     String
  nodeId      String // Matches React Flow node ID
  result      String?   @db.Text // AI-generated result content
  completed   Boolean   @default(false)
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  swarm Swarm @relation(fields: [swarmId], references: [id], onDelete: Cascade)

  @@unique([userId, swarmId, nodeId])
  @@index([userId, swarmId])
  @@index([swarmId])
  @@map("step_results")
}
