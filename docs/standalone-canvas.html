<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audit Workflow</title>

  <!-- React 18.3.1 -->
  <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js"></script>

  <!-- Babel for JSX (no build step) -->
  <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>

  <!-- ReactFlow 11.11.4 -->
  <script src="https://unpkg.com/reactflow@11.11.4/dist/umd/index.js"></script>
  <link href="https://unpkg.com/reactflow@11.11.4/dist/style.css" rel="stylesheet" />

  <!-- Dagre for auto-layout -->
  <script src="https://unpkg.com/@dagrejs/dagre@1.1.8/dist/dagre.min.js"></script>

  <!-- Tailwind CSS Play CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    html, body, #root {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* ReactFlow handle overrides */
    .react-flow__handle {
      width: 12px !important;
      height: 12px !important;
      background-color: #9ca3af !important;
      border: 2px solid white !important;
    }

    .react-flow__handle:hover {
      background-color: #6366f1 !important;
    }

    /* Modal animations */
    .modal-backdrop {
      animation: fadeIn 0.15s ease-out;
    }

    .modal-content {
      animation: slideIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.95) !important;
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) !important;
      }
    }

    #modal-root {
      position: relative;
      z-index: 9999;
    }

    /* Empty state overlay */
    .empty-state-overlay {
      pointer-events: none;
    }

    .empty-state-overlay > div {
      pointer-events: auto;
    }

    /* Edge hover styles */
    .react-flow__edge path {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div id="modal-root"></div>

  <script type="text/babel">
    const { useState, useCallback, useEffect, useRef, memo } = React;
    const { createPortal } = ReactDOM;
    const {
      ReactFlowProvider,
      ReactFlow,
      Background,
      Controls,
      MiniMap,
      Panel,
      addEdge,
      applyNodeChanges,
      applyEdgeChanges,
      Handle,
      Position,
      getBezierPath,
      EdgeLabelRenderer,
      useReactFlow,
      BackgroundVariant
    } = window.ReactFlow;

    // ============================================
    // Constants
    // ============================================
    const GRID_SIZE = 20;
    const LOCAL_STORAGE_KEY = 'auditswarm-workflow-canvas';
    const COLLECTIVE_SWARM_DATA = null; // @CSDATA

    const DEFAULT_EDGE_STYLE = {
      stroke: '#6366f1',
      strokeWidth: 2,
      strokeDasharray: '5,5'
    };

    const DEFAULT_LAYOUT_OPTIONS = {
      direction: 'LR',
      nodeWidth: 300,
      nodeHeight: 120,
      horizontalSpacing: 50,
      verticalSpacing: 100
    };

    // ============================================
    // SVG Icons (inline)
    // ============================================
    const PlusIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="12" y1="5" x2="12" y2="19" />
        <line x1="5" y1="12" x2="19" y2="12" />
      </svg>
    );

    const FileTextIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" />
        <polyline points="14 2 14 8 20 8" />
        <line x1="16" y1="13" x2="8" y2="13" />
        <line x1="16" y1="17" x2="8" y2="17" />
        <polyline points="10 9 9 9 8 9" />
      </svg>
    );

    const Settings2Icon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M20 7h-9" />
        <path d="M14 17H5" />
        <circle cx="17" cy="17" r="3" />
        <circle cx="7" cy="7" r="3" />
      </svg>
    );

    const Trash2Icon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="3 6 5 6 21 6" />
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
        <line x1="10" y1="11" x2="10" y2="17" />
        <line x1="14" y1="11" x2="14" y2="17" />
      </svg>
    );

    const XIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </svg>
    );

    const UploadIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
        <polyline points="17 8 12 3 7 8" />
        <line x1="12" y1="3" x2="12" y2="15" />
      </svg>
    );

    const DownloadIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
        <polyline points="7 10 12 15 17 10" />
        <line x1="12" y1="15" x2="12" y2="3" />
      </svg>
    );

    const ClipboardIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" />
        <rect x="8" y="2" width="8" height="4" rx="1" ry="1" />
      </svg>
    );

    const SparklesIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" />
        <path d="M5 3v4" />
        <path d="M19 17v4" />
        <path d="M3 5h4" />
        <path d="M17 19h4" />
      </svg>
    );

    const LinkIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
      </svg>
    );

    const PanelRightCloseIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect width="18" height="18" x="3" y="3" rx="2" />
        <path d="M15 3v18" />
        <path d="m8 9 3 3-3 3" />
      </svg>
    );

    const PanelRightIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <rect width="18" height="18" x="3" y="3" rx="2" />
        <path d="M15 3v18" />
      </svg>
    );

    const SaveIcon = ({ className }) => (
      <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
        <polyline points="17 21 17 13 7 13 7 21" />
        <polyline points="7 3 7 8 15 8" />
      </svg>
    );

    const ChevronDownIcon = ({ className, style }) => (
      <svg className={className} style={style} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="6 9 12 15 18 9" />
      </svg>
    );

    // ============================================
    // Utility Functions
    // ============================================

    function nodesNeedLayout(nodes) {
      if (nodes.length === 0) return false;
      return nodes.some(node =>
        !node.position ||
        typeof node.position.x !== 'number' ||
        typeof node.position.y !== 'number'
      );
    }

    function applyDagreLayout(nodes, edges, options = {}) {
      if (nodes.length === 0) return [];

      const opts = { ...DEFAULT_LAYOUT_OPTIONS, ...options };
      const g = new dagre.graphlib.Graph();

      g.setGraph({
        rankdir: opts.direction,
        nodesep: opts.horizontalSpacing,
        ranksep: opts.verticalSpacing,
        marginx: 50,
        marginy: 50
      });

      g.setDefaultEdgeLabel(() => ({}));

      nodes.forEach(node => {
        g.setNode(node.id, {
          width: opts.nodeWidth,
          height: opts.nodeHeight
        });
      });

      edges.forEach(edge => {
        if (g.hasNode(edge.source) && g.hasNode(edge.target)) {
          g.setEdge(edge.source, edge.target);
        }
      });

      dagre.layout(g);

      return nodes.map(node => {
        const nodeWithPosition = g.node(node.id);
        return {
          ...node,
          type: 'step',
          position: {
            x: Math.round(nodeWithPosition.x - opts.nodeWidth / 2),
            y: Math.round(nodeWithPosition.y - opts.nodeHeight / 2)
          }
        };
      });
    }

    function normalizeEdges(edges) {
      return edges.map(edge => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        type: 'deletable',
        animated: true,
        style: { ...DEFAULT_EDGE_STYLE }
      }));
    }

    function processImportedWorkflow(jsonData) {
      let data = jsonData;

      // Handle double-stringified JSON
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) {
          throw new Error('Invalid JSON format');
        }
      }

      // Handle AuditSwarm export format
      if (data.data?.workflows?.[0]?.diagramJson) {
        data = data.data.workflows[0].diagramJson;
      }

      // Handle direct diagramJson format
      if (data.diagramJson) {
        data = data.diagramJson;
      }

      const nodes = data.nodes || [];
      const edges = data.edges || [];

      // Check if any nodes lack real positions before normalizing
      const needsLayout = nodes.length > 0 && nodes.some(node =>
        !node.position ||
        typeof node.position.x !== 'number' ||
        typeof node.position.y !== 'number'
      );

      // Normalize nodes
      let normalizedNodes = nodes.map(node => ({
        id: node.id,
        type: 'step',
        position: node.position || { x: 0, y: 0 },
        data: {
          label: node.data?.label || 'Untitled',
          description: node.data?.description || '',
          instructions: node.data?.instructions || '',
          linkedAgentUrl: node.data?.linkedAgentUrl || ''
        }
      }));

      // Also detect all nodes stacked at the same point (e.g. all at 0,0)
      const allSamePosition = normalizedNodes.length > 1 && normalizedNodes.every(
        n => n.position.x === normalizedNodes[0].position.x &&
             n.position.y === normalizedNodes[0].position.y
      );

      // Apply dagre layout if positions are missing or all identical
      if (needsLayout || allSamePosition) {
        normalizedNodes = applyDagreLayout(normalizedNodes, edges);
      }

      const normalizedEdges = normalizeEdges(edges);

      return { nodes: normalizedNodes, edges: normalizedEdges };
    }

    // ============================================
    // Modal Component
    // ============================================
    function Modal({ isOpen, onClose, title, description, children, wide = false }) {
      useEffect(() => {
        if (!isOpen) return;

        const handleEscape = (e) => {
          if (e.key === 'Escape') onClose();
        };

        document.addEventListener('keydown', handleEscape);
        document.body.style.overflow = 'hidden';

        return () => {
          document.removeEventListener('keydown', handleEscape);
          document.body.style.overflow = '';
        };
      }, [isOpen, onClose]);

      if (!isOpen) return null;

      const modalRoot = document.getElementById('modal-root');

      return createPortal(
        <div className="fixed inset-0" style={{ zIndex: 9999 }}>
          {/* Backdrop */}
          <div
            className="modal-backdrop fixed inset-0 bg-black/50 backdrop-blur-sm"
            onClick={onClose}
          />

          {/* Content */}
          <div
            className="modal-content fixed bg-white rounded-lg shadow-xl"
            style={{
              left: '50%',
              top: '50%',
              transform: 'translate(-50%, -50%)',
              width: '100%',
              maxWidth: wide ? '56rem' : '32rem',
              zIndex: 10000
            }}
          >
            <div className="flex flex-col p-6">
              {/* Header */}
              <div className="flex items-start justify-between mb-4">
                <div>
                  {title && <h2 className="text-lg font-semibold text-gray-900">{title}</h2>}
                  {description && <p className="text-sm text-gray-500 mt-1">{description}</p>}
                </div>
                <button
                  onClick={onClose}
                  className="p-1 rounded-md hover:bg-gray-100 transition-colors"
                >
                  <XIcon className="h-5 w-5 text-gray-500" />
                </button>
              </div>

              {/* Body */}
              {children}
            </div>
          </div>
        </div>,
        modalRoot
      );
    }

    // ============================================
    // Node Detail Panel (Editable sidebar)
    // ============================================
    function NodeDetailPanel({ selectedNode, onClose, onUpdate }) {
      if (!selectedNode) return null;

      const data = selectedNode.data || {};

      const handleChange = (field, value) => {
        onUpdate(selectedNode.id, { [field]: value });
      };

      return (
        <div className="h-full flex flex-col">
          {/* Panel Header with Title */}
          <div className="flex-shrink-0 px-5 pt-4 pb-3">
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-gray-600">Title</label>
              <button
                onClick={onClose}
                className="p-1 text-gray-400 hover:text-gray-600 rounded-md hover:bg-gray-100 transition-colors -mr-1"
              >
                <XIcon className="h-4 w-4" />
              </button>
            </div>
            <input
              type="text"
              value={data.label || ''}
              onChange={(e) => handleChange('label', e.target.value)}
              placeholder="Step name"
              className="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
            />
          </div>

          {/* Panel Content */}
          <div className="flex-1 overflow-y-auto px-5 py-5 space-y-5">

            {/* Description */}
            <div>
              <label className="block text-sm font-medium text-gray-600 mb-2">Description</label>
              <textarea
                value={data.description || ''}
                onChange={(e) => handleChange('description', e.target.value)}
                placeholder="Brief description of this step"
                rows={3}
                className="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 resize-none"
              />
            </div>

            {/* Instructions */}
            <div>
              <label className="block text-sm font-medium text-gray-600 mb-2">Instructions</label>
              <textarea
                value={data.instructions || ''}
                onChange={(e) => handleChange('instructions', e.target.value)}
                placeholder="Detailed instructions for this step"
                rows={8}
                className="w-full px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 resize-vertical"
              />
            </div>

            {/* Completed */}
            <div className="pt-2 border-t border-gray-200">
              <label className="flex items-center gap-3 cursor-pointer">
                <input
                  type="checkbox"
                  checked={!!data.completed}
                  onChange={(e) => handleChange('completed', e.target.checked)}
                  className="h-4 w-4 rounded border-gray-300 text-green-600 focus:ring-green-500"
                />
                <span className="text-sm font-medium text-gray-700">Completed</span>
              </label>
            </div>
          </div>
        </div>
      );
    }

    // ============================================
    // Import Modal (Paste JSON)
    // ============================================
    function ImportModal({ isOpen, onClose, onImport }) {
      const [jsonText, setJsonText] = useState('');
      const [error, setError] = useState('');

      const handleSubmit = (e) => {
        e.preventDefault();
        setError('');

        try {
          let text = jsonText.trim();

          // If the input is a quoted string (double-stringified JSON), unwrap it
          if (text.startsWith('"') && text.endsWith('"')) {
            text = JSON.parse(text);
          }

          const data = typeof text === 'string' ? JSON.parse(text) : text;
          const processed = processImportedWorkflow(data);
          onImport(processed);
          setJsonText('');
          onClose();
        } catch (err) {
          setError(err.message || 'Invalid JSON format');
        }
      };

      return (
        <Modal
          isOpen={isOpen}
          onClose={onClose}
          title="Import Workflow from JSON"
          description="Paste your workflow JSON below"
        >
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <textarea
                value={jsonText}
                onChange={(e) => setJsonText(e.target.value)}
                placeholder='{"nodes": [...], "edges": [...]}'
                rows={10}
                className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 resize-none font-mono text-sm"
              />
              {error && (
                <p className="text-sm text-red-600">{error}</p>
              )}
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                Cancel
              </button>
              <button
                type="submit"
                className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                Import
              </button>
            </div>
          </form>
        </Modal>
      );
    }

    // ============================================
    // Workflow Generation Prompt
    // ============================================
    const WORKFLOW_GENERATION_PROMPT = `# Audit Workflow Designer Prompt

You are an expert in designing workflows for internal audit procedures. Given the attached file(s), design a workflow for internal auditors and AI agents to complete. Focus on **what each step does** and **what context it needs**.

---

## Core Principle: Context Engineering

**Edges represent data dependencies, not visual sequence.** Each edge means the output of one node becomes required input for another. This is the most critical aspect of workflow design.

When designing a workflow, think about:
1. What does each step produce?
2. What does each step need to consume?
3. How do outputs flow from one step to the next?
4. Are there any upstream data required for this step (there may not be any pertinent upstream context)


Core Principle: Quality + Quantity
1. Include as many nodes/steps as needed (do not limit the number)
2. Make sure the quality (context and prompts) of the each of the steps is expertly designed

---

## Workflow Design Process

### Step 1: Understand the Source Document
Read the audit document and identify:
- The phase (Planning, Fieldwork, Reporting, Monitoring) - if not clear ask the user to specify
- Distinct procedures or deliverables
- Natural dependencies between steps

### Step 2: Define Nodes (Audit Artifacts)
For each distinct step in the given phase, define:
- **id**: kebab-case identifier (e.g., \`risk-assessment\`)
- **label**: 3-6 word action title using verbs (Assess, Document, Evaluate, Review, Test, Verify)
- **description**: One sentence explaining what the step produces
- **instructions**: Detailed prompt (see instruction templates below)

Note, the steps the step types in each phase:
• Pre-planning (Internal Audit Plan Development): Include only steps related to the organization-wide risk assessment, defining the audit universe, and establishing the annual or multiyear internal audit plan. This phase focuses on prioritizing risks at the organizational level to determine which engagements to perform.
• Planning (Engagement Planning): Include only steps related to understanding the specific activity under review, performing an engagement-level risk assessment, and establishing the engagement's objectives and scope. This phase must culminate in a documented engagement work program that identifies tasks and internal auditors assigned.
• Fieldwork (Conducting Engagement Work): Include only steps involved in implementing the work program, such as gathering information, performing analyses, and evaluating evidence. This phase is restricted to identifying potential findings, determining their causes and effects, and developing initial conclusions.
• Reporting (Communicating Results): Include only steps for developing and disseminating the final engagement communication, which must include objectives, scope, findings, and conclusions. This phase also includes obtaining management action plans and conducting follow-up to confirm implementation.
• Quality Assurance (QA): Include only steps regarding the Quality Assurance and Improvement Program (QAIP), such as ongoing monitoring through supervisory reviews, periodic internal self-assessments, and external assessments. These steps verify conformance with the Standards and the achievement of performance objectives across all other phases.

### Step 3: Map Data Dependencies (Edges)
This is the most important step. For each node, ask:
- "What outputs from prior steps does this node need?"
- "What specific artifacts must be referenced in the instructions?"

Create edges only where real data dependencies exist. Every edge should correspond to an explicit reference in the downstream node's instructions.

### Step 4: Generate JSON
Output the workflow JSON following the schema below.

---

## Writing Effective Instructions

### First/Root Nodes (No Upstream Dependencies)
These nodes receive external inputs (documents, data, user context):

\`\`\`
You are an [role].

**External Inputs Required:**
- [List what documents/data this step needs from the user]

**Task:**
[Specific task to perform]

**Output:**
A [markdown/JSON] file containing [detailed format specification with field names].

Reference [Standard Section] for requirements.
\`\`\`

### Downstream Nodes (With Upstream Context)
\`\`\`
You are a [role].

**Input Context:**
1. The [artifact 1] from [Step A] containing [fields/structure]
2. The [artifact 2] from [Step B] containing [fields/structure]

**Task:**
Synthesize these inputs to [specific task]. Cross-reference [artifact 1] with [artifact 2] to [purpose].

**Output:**
A [markdown/JSON] file containing [detailed format specification].
\`\`\`

---

## JSON Schema

### Overall Structure

\`\`\`json
{
  "version": "1.0",
  "data": {
    "workflows": [
      {
        "name": "[Phase]: [Descriptive Workflow Name]",
        "description": "[2-3 sentence description of purpose and source standard]",
        "diagramJson": {
          "nodes": [...],
          "edges": [...],
        }
      }
    ]
  }
}
\`\`\`

### Node Schema

\`\`\`json
{
  "id": "kebab-case-unique-id",
  "data": {
    "label": "3-6 Word Action Title",
    "description": "One sentence explaining what this step produces",
    "instructions": "Full prompt with Input Context, Task, and Output sections"
  }
}
\`\`\`

**Do NOT include** \`type\` or \`position\` - these are auto-applied.

### Edge Schema

\`\`\`json
{
  "id": "e-source-id-target-id",
  "source": "source-node-id",
  "target": "target-node-id"
}
\`\`\`

**Do NOT include** \`type\`, \`animated\`, or \`style\` - these are auto-applied.

---

## Validation Checklist

Before outputting, verify:

### Structure
- All node IDs are unique and kebab-case
- All edge IDs follow pattern \`e-[source]-[target]\`
- All edges reference valid source and target node IDs
- JSON is valid (no trailing commas, proper quotes)

### Instructions Quality
- Each instruction sets a clear role
- Root nodes specify what external inputs they need
- Downstream nodes explicitly reference upstream outputs by name and format
- Output format is specified (.md or .json) with structure details

### Context Engineering (Edges)
- Each edge represents a real data dependency
- Every edge corresponds to an explicit reference in the target node's instructions
- No orphan references (instructions don't reference artifacts without corresponding edges)

---

## Quick Reference: Minimal Node

\`\`\`json
{
  "id": "step-id",
  "data": {
    "label": "Action Title",
    "description": "What this produces",
    "instructions": "You are a [role].\\n\\n**Input Context:**\\n[What you receive]\\n\\n**Task:**\\n[What to do]\\n\\n**Output:**\\n[Format and structure]"
  }
}
\`\`\`

## Quick Reference: Minimal Edge

\`\`\`json
{ "id": "e-from-to", "source": "from-node-id", "target": "to-node-id" }
\`\`\`

---

## Output Instructions

Output ONLY raw JSON. Do not wrap it in quotes, do not escape any characters, do not add backticks, and do not include explanations.
THE OUTPUT SHOULD ONLY BE A JSON CODEBLOCK.`;

    // ============================================
    // Prompt Modal
    // ============================================
    function PromptModal({ isOpen, onClose }) {
      const [copied, setCopied] = useState(false);

      const handleCopy = useCallback(() => {
        navigator.clipboard.writeText(WORKFLOW_GENERATION_PROMPT).then(() => {
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        });
      }, []);

      return (
        <Modal
          isOpen={isOpen}
          onClose={onClose}
          title="AI Workflow Generation Prompt"
          description="Copy this prompt and paste it into your AI assistant (Claude, ChatGPT, etc.) to generate workflow JSON"
          wide={true}
        >
          <div className="space-y-4">
            <div className="space-y-2">
              <div className="relative">
                <pre className="w-full h-96 px-3 py-2 border border-gray-300 rounded-md bg-gray-50 overflow-auto text-xs font-mono whitespace-pre-wrap">
                  {WORKFLOW_GENERATION_PROMPT}
                </pre>
              </div>
              <p className="text-xs text-gray-500">
                After generating the JSON, use "Import File" or "Paste JSON" to load it into the canvas.
              </p>
            </div>

            <div className="flex justify-end gap-2 pt-4">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                Close
              </button>
              <button
                type="button"
                onClick={handleCopy}
                className="px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500"
              >
                {copied ? 'Copied!' : 'Copy Prompt'}
              </button>
            </div>
          </div>
        </Modal>
      );
    }

    // ============================================
    // StepNode Component
    // ============================================
    const StepNode = memo(({ id, data, selected }) => {
      const { setNodes, setEdges } = useReactFlow();
      const readOnly = data.readOnly || false;
      const isSelected = selected || data.isSelected || false;

      const onDelete = useCallback(() => {
        setNodes((nodes) => nodes.filter((node) => node.id !== id));
        setEdges((edges) => edges.filter((edge) => edge.source !== id && edge.target !== id));
      }, [id, setNodes, setEdges]);

      return (
        <div
          className={`
            relative min-w-[280px] max-w-[320px] rounded-lg border-2 bg-white shadow-lg transition-all hover:shadow-xl
            cursor-pointer group
            ${isSelected
              ? 'border-amber-500 ring-2 ring-amber-500/30 shadow-amber-200/50'
              : data.completed
                ? 'border-green-500 ring-2 ring-green-500/30'
                : 'border-gray-300'
            }
          `}
        >
          <Handle
            type="target"
            position={Position.Left}
            style={{ left: -7 }}
          />

          {/* Delete button */}
          {!readOnly && (
            <button
              onClick={(e) => {
                e.stopPropagation();
                onDelete();
              }}
              className="absolute -right-2 -top-2 flex h-6 w-6 items-center justify-center rounded-full bg-red-500 text-white opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600 shadow-md z-10"
              title="Delete node"
            >
              <Trash2Icon className="h-3 w-3" />
            </button>
          )}

          <div className="p-4">
            {/* Header with icon and title */}
            <div className="flex items-start gap-3 mb-2">
              <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-blue-100 flex items-center justify-center">
                <FileTextIcon className="h-5 w-5 text-blue-600" />
              </div>

              <div className="flex-1 min-w-0">
                <h3 className="text-sm font-semibold text-gray-900 line-clamp-2">
                  {data.label || 'New Step'}
                </h3>
              </div>
            </div>

            {/* Description */}
            {data.description && (
              <p className="text-xs text-gray-600 line-clamp-2">
                {data.description}
              </p>
            )}
          </div>

          <Handle
            type="source"
            position={Position.Right}
            style={{ right: -7 }}
          />
        </div>
      );
    });

    StepNode.displayName = 'StepNode';

    // ============================================
    // DeletableEdge Component
    // ============================================
    const DeletableEdge = ({
      id,
      sourceX,
      sourceY,
      targetX,
      targetY,
      sourcePosition,
      targetPosition,
      style = {},
      markerEnd,
      data
    }) => {
      const { setEdges } = useReactFlow();
      const [isHovered, setIsHovered] = useState(false);
      const readOnly = data?.readOnly || false;

      const [edgePath, labelX, labelY] = getBezierPath({
        sourceX,
        sourceY,
        sourcePosition,
        targetX,
        targetY,
        targetPosition,
      });

      const onEdgeClick = useCallback((evt) => {
        evt.stopPropagation();
        setEdges((edges) => edges.filter((edge) => edge.id !== id));
      }, [id, setEdges]);

      return (
        <>
          {/* Invisible wider path for hover detection */}
          <path
            d={edgePath}
            fill="none"
            strokeWidth={20}
            stroke="transparent"
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            style={{ cursor: 'pointer' }}
          />
          {/* Visible edge */}
          <path
            d={edgePath}
            fill="none"
            markerEnd={markerEnd}
            style={{
              stroke: style.stroke || '#6366f1',
              strokeWidth: style.strokeWidth || 2,
              strokeDasharray: style.strokeDasharray || '5,5',
              pointerEvents: 'none',
            }}
          />
          {!readOnly && (
            <EdgeLabelRenderer>
              <div
                style={{
                  position: 'absolute',
                  transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
                  pointerEvents: 'all',
                }}
                className="nodrag nopan"
                onMouseEnter={() => setIsHovered(true)}
                onMouseLeave={() => setIsHovered(false)}
              >
                <button
                  className={`w-5 h-5 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center transition-opacity shadow-md ${
                    isHovered ? 'opacity-100' : 'opacity-0'
                  }`}
                  onClick={onEdgeClick}
                  title="Delete connection"
                >
                  <XIcon className="h-3 w-3" />
                </button>
              </div>
            </EdgeLabelRenderer>
          )}
        </>
      );
    };

    // ============================================
    // Node and Edge Types
    // ============================================
    const nodeTypes = { step: StepNode };
    const edgeTypes = { deletable: DeletableEdge };

    // ============================================
    // Main App Component
    // ============================================
    function WorkflowCanvas() {
      const [nodes, setNodes] = useState([]);
      const [edges, setEdges] = useState([]);
      const [selectedNode, setSelectedNode] = useState(null);
      const [sidebarOpen, setSidebarOpen] = useState(false);
      const [showImportModal, setShowImportModal] = useState(false);
      const [showPromptModal, setShowPromptModal] = useState(false);
      const fileInputRef = useRef(null);

      // Load from embedded data or localStorage on mount
      useEffect(() => {
        try {
          if (COLLECTIVE_SWARM_DATA) {
            if (COLLECTIVE_SWARM_DATA.nodes) setNodes(COLLECTIVE_SWARM_DATA.nodes);
            if (COLLECTIVE_SWARM_DATA.edges) setEdges(COLLECTIVE_SWARM_DATA.edges);
            return;
          }
          const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
          if (saved) {
            const data = JSON.parse(saved);
            if (data.nodes) setNodes(data.nodes);
            if (data.edges) setEdges(data.edges);
          }
        } catch (e) {
          console.warn('Failed to load from localStorage:', e);
        }
      }, []);

      // Save to localStorage on change
      useEffect(() => {
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify({ nodes, edges }));
        } catch (e) {
          console.warn('Failed to save to localStorage:', e);
        }
      }, [nodes, edges]);

      const onNodesChange = useCallback((changes) => {
        setNodes((nds) => applyNodeChanges(changes, nds));
      }, []);

      const onEdgesChange = useCallback((changes) => {
        setEdges((eds) => applyEdgeChanges(changes, eds));
      }, []);

      const onConnect = useCallback((params) => {
        setEdges((eds) => addEdge({
          ...params,
          type: 'deletable',
          animated: true,
          style: { ...DEFAULT_EDGE_STYLE }
        }, eds));
      }, []);

      // Add new step node
      const handleAddStep = useCallback(() => {
        const nodeWidth = 300;
        const nodeSpacing = 100;

        let maxX = 0;
        let avgY = 200;

        if (nodes.length > 0) {
          maxX = Math.max(...nodes.map(n => n.position.x + nodeWidth));
          avgY = nodes.reduce((sum, n) => sum + n.position.y, 0) / nodes.length;
        }

        const position = {
          x: Math.round((maxX + nodeSpacing) / GRID_SIZE) * GRID_SIZE,
          y: Math.round(avgY / GRID_SIZE) * GRID_SIZE
        };

        const newNode = {
          id: `step_${Date.now()}`,
          type: 'step',
          position,
          data: {
            label: 'New Step',
            description: '',
            instructions: '',
            linkedAgentUrl: ''
          }
        };

        setNodes((nds) => [...nds, newNode]);
      }, [nodes]);

      // Handle node click - open sidebar with details
      const handleNodeClick = useCallback((_event, node) => {
        setSelectedNode(node);
        setSidebarOpen(true);
      }, []);

      // Close node detail panel
      const handleCloseNodeView = useCallback(() => {
        setSelectedNode(null);
        setSidebarOpen(false);
      }, []);

      // Click on canvas background - deselect and close sidebar
      const handlePaneClick = useCallback(() => {
        setSelectedNode(null);
        setSidebarOpen(false);
      }, []);

      // Update node data from the detail panel
      const handleNodeUpdate = useCallback((nodeId, updates) => {
        setNodes((nds) =>
          nds.map((node) =>
            node.id === nodeId
              ? { ...node, data: { ...node.data, ...updates } }
              : node
          )
        );
        setSelectedNode((prev) =>
          prev && prev.id === nodeId
            ? { ...prev, data: { ...prev.data, ...updates } }
            : prev
        );
      }, []);

      // Sync selectedNode when a node is deleted
      useEffect(() => {
        if (selectedNode && !nodes.find(n => n.id === selectedNode.id)) {
          setSelectedNode(null);
          setSidebarOpen(false);
        }
      }, [nodes, selectedNode]);

      // Save/Load dropdown state
      const [showSaveMenu, setShowSaveMenu] = useState(false);
      const [showLoadMenu, setShowLoadMenu] = useState(false);
      const saveMenuRef = useRef(null);
      const loadMenuRef = useRef(null);
      const htmlFileHandleRef = useRef(null);
      const jsonFileHandleRef = useRef(null);

      // Close dropdown menus on outside click
      useEffect(() => {
        const handleClickOutside = (e) => {
          if (saveMenuRef.current && !saveMenuRef.current.contains(e.target)) {
            setShowSaveMenu(false);
          }
          if (loadMenuRef.current && !loadMenuRef.current.contains(e.target)) {
            setShowLoadMenu(false);
          }
        };
        document.addEventListener('click', handleClickOutside);
        return () => document.removeEventListener('click', handleClickOutside);
      }, []);

      // Helper to write to a File System Access API handle
      const writeToHandle = useCallback(async (handle, blob) => {
        const writable = await handle.createWritable();
        await writable.write(blob);
        await writable.close();
      }, []);

      // Save data as JSON
      const handleSaveJson = useCallback(async () => {
        setShowSaveMenu(false);
        const exportData = {
          version: '1.0',
          data: {
            workflows: [{
              name: 'Exported Workflow',
              description: '',
              diagramJson: {
                nodes: nodes.map(n => ({
                  id: n.id,
                  type: n.type,
                  position: n.position,
                  data: {
                    label: n.data.label,
                    description: n.data.description,
                    instructions: n.data.instructions,
                    linkedAgentUrl: n.data.linkedAgentUrl,
                    completed: n.data.completed || false
                  }
                })),
                edges: edges.map(e => ({
                  id: e.id,
                  source: e.source,
                  target: e.target
                })),
                metadata: {}
              }
            }]
          }
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });

        try {
          if (!jsonFileHandleRef.current) {
            jsonFileHandleRef.current = await window.showSaveFilePicker({
              suggestedName: 'audit-workflow.json',
              types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
            });
          }
          await writeToHandle(jsonFileHandleRef.current, blob);
        } catch (e) {
          if (e.name === 'AbortError') return;
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'audit-workflow.json';
          a.click();
          URL.revokeObjectURL(a.href);
        }
      }, [nodes, edges, writeToHandle]);

      // Save graph as HTML
      const handleSaveHtml = useCallback(async () => {
        setShowSaveMenu(false);
        const dataToEmbed = JSON.stringify({ nodes, edges });
        const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
        const finalHtml = html.replace(
          /const COLLECTIVE_SWARM_DATA = .+; \/\/ @CSDATA/,
          'const COLLECTIVE_SWARM_DATA = ' + dataToEmbed + '; // @CSDATA'
        );

        const blob = new Blob([finalHtml], { type: 'text/html' });

        try {
          if (!htmlFileHandleRef.current) {
            htmlFileHandleRef.current = await window.showSaveFilePicker({
              suggestedName: 'audit-workflow.html',
              types: [{ description: 'HTML', accept: { 'text/html': ['.html'] } }]
            });
          }
          await writeToHandle(htmlFileHandleRef.current, blob);
        } catch (e) {
          if (e.name === 'AbortError') return;
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'audit-workflow.html';
          a.click();
          URL.revokeObjectURL(a.href);
        }
      }, [nodes, edges, writeToHandle]);

      // Import from file
      const handleFileImport = useCallback((e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            let jsonData = event.target.result;

            // Handle double-stringified JSON
            if (typeof jsonData === 'string') {
              jsonData = JSON.parse(jsonData);
            }

            const processed = processImportedWorkflow(jsonData);
            setNodes(processed.nodes);
            setEdges(processed.edges);
          } catch (err) {
            alert('Failed to import: ' + (err.message || 'Invalid JSON'));
          }
        };
        reader.readAsText(file);

        // Reset file input
        e.target.value = '';
      }, []);

      // Import from pasted JSON
      const handlePasteImport = useCallback((processed) => {
        setNodes(processed.nodes);
        setEdges(processed.edges);
      }, []);

      // Clear canvas
      const handleClear = useCallback(() => {
        if (nodes.length === 0 && edges.length === 0) return;
        if (confirm('Are you sure you want to clear the canvas? This cannot be undone.')) {
          setNodes([]);
          setEdges([]);
        }
      }, [nodes.length, edges.length]);

      const isEmpty = nodes.length === 0;

      return (
        <div className="w-full h-full flex flex-col">
          {/* Header */}
          <div className="flex-shrink-0 bg-white border-b border-gray-200 px-4 py-2" style={{ height: 52 }}>
            <div className="flex items-center justify-between h-full">
              {/* Left: Logo + title + subtitle */}
              <a
                href="https://www.linkedin.com/in/richardpenfil/"
                target="_blank"
                rel="noopener noreferrer"
                className="flex items-center gap-3 no-underline text-inherit hover:opacity-80 transition-opacity"
              >
                <div className="w-10 h-10 rounded-xl shadow-lg flex items-center justify-center" style={{ background: 'linear-gradient(135deg, #f59e0b, #d97706)', boxShadow: '0 4px 14px rgba(245, 158, 11, 0.5)' }}>
                  <svg className="w-6 h-6 text-black" fill="none" stroke="currentColor" viewBox="0 0 24 24" strokeWidth="1.5">
                    <ellipse cx="12" cy="14" rx="4" ry="5" strokeLinecap="round" strokeLinejoin="round"/>
                    <path strokeLinecap="round" d="M8.5 12.5h7M8.2 15h7.6"/>
                    <circle cx="12" cy="7.5" r="2.5"/>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 5.5L9 3M13.5 5.5L15 3"/>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M8 11.5c-2-1-3.5-0.5-4 1M16 11.5c2-1 3.5-0.5 4 1"/>
                  </svg>
                </div>
                <div>
                  <div className="font-black text-sm text-gray-900 leading-tight">Audit Workflow</div>
                  <div className="text-xs text-gray-500 font-medium">Auditor in the Loop</div>
                </div>
              </a>

              {/* Right: Load + Save + sidebar toggle */}
              <div className="flex items-center gap-2">
                {/* Hidden file input for import */}
                <input
                  ref={fileInputRef}
                  type="file"
                  accept=".json"
                  onChange={handleFileImport}
                  className="hidden"
                />

                {/* Load dropdown */}
                <div className="relative" ref={loadMenuRef}>
                  <button
                    onClick={(e) => { e.stopPropagation(); setShowLoadMenu(!showLoadMenu); }}
                    className="inline-flex items-center px-3 py-1.5 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors"
                  >
                    <UploadIcon className="h-4 w-4 mr-1.5" />
                    Load
                    <ChevronDownIcon className="h-3 w-3" style={{ marginLeft: 4 }} />
                  </button>
                  {showLoadMenu && (
                    <div className="absolute top-full right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50" style={{ minWidth: 180 }}>
                      <button
                        onClick={() => { setShowLoadMenu(false); fileInputRef.current?.click(); }}
                        className="flex items-center gap-2 w-full px-3 py-2.5 text-sm text-gray-700 hover:bg-gray-50 rounded-t-lg"
                      >
                        <UploadIcon className="h-4 w-4 text-gray-400" />
                        <span className="flex-1 text-left">Import File</span>
                        <span className="text-xs text-gray-400">.json</span>
                      </button>
                      <button
                        onClick={() => { setShowLoadMenu(false); setShowImportModal(true); }}
                        className="flex items-center gap-2 w-full px-3 py-2.5 text-sm text-gray-700 hover:bg-gray-50"
                      >
                        <ClipboardIcon className="h-4 w-4 text-gray-400" />
                        <span className="flex-1 text-left">Paste JSON</span>
                      </button>
                      <button
                        onClick={() => { setShowLoadMenu(false); setShowPromptModal(true); }}
                        className="flex items-center gap-2 w-full px-3 py-2.5 text-sm text-gray-700 hover:bg-gray-50 rounded-b-lg"
                      >
                        <SparklesIcon className="h-4 w-4 text-gray-400" />
                        <span className="flex-1 text-left">AI Generate</span>
                      </button>
                    </div>
                  )}
                </div>

                {/* Save dropdown */}
                <div className="relative" ref={saveMenuRef}>
                  <button
                    onClick={(e) => { e.stopPropagation(); setShowSaveMenu(!showSaveMenu); }}
                    disabled={isEmpty}
                    className="inline-flex items-center px-3 py-1.5 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    <SaveIcon className="h-4 w-4 mr-1.5" />
                    Save
                    <ChevronDownIcon className="h-3 w-3" style={{ marginLeft: 4 }} />
                  </button>
                  {showSaveMenu && (
                    <div className="absolute top-full right-0 mt-1 bg-white border border-gray-200 rounded-lg shadow-lg z-50" style={{ minWidth: 160 }}>
                      <button
                        onClick={handleSaveHtml}
                        className="flex items-center gap-2 w-full px-3 py-2.5 text-sm text-gray-700 hover:bg-gray-50 rounded-t-lg"
                      >
                        <FileTextIcon className="h-4 w-4 text-gray-400" />
                        <span className="flex-1 text-left">Save Graph</span>
                        <span className="text-xs text-gray-400">HTML</span>
                      </button>
                      <button
                        onClick={handleSaveJson}
                        className="flex items-center gap-2 w-full px-3 py-2.5 text-sm text-gray-700 hover:bg-gray-50 rounded-b-lg"
                      >
                        <DownloadIcon className="h-4 w-4 text-gray-400" />
                        <span className="flex-1 text-left">Save Data</span>
                        <span className="text-xs text-gray-400">JSON</span>
                      </button>
                    </div>
                  )}
                </div>

                {/* Sidebar toggle */}
                <div className="h-6 w-px bg-gray-200" />
                <button
                  onClick={() => setSidebarOpen(!sidebarOpen)}
                  className="inline-flex items-center justify-center w-8 h-8 text-gray-600 hover:text-gray-900 hover:bg-gray-100 rounded-md transition-colors"
                  title={sidebarOpen ? 'Hide sidebar' : 'Show sidebar'}
                >
                  {sidebarOpen
                    ? <PanelRightCloseIcon className="h-4 w-4" />
                    : <PanelRightIcon className="h-4 w-4" />
                  }
                </button>
              </div>
            </div>
          </div>

          {/* Main content area */}
          <div className="flex-1 flex overflow-hidden">
            {/* Canvas */}
            <div className="flex-1 relative">
              <ReactFlow
                nodes={nodes}
                edges={edges}
                onNodesChange={onNodesChange}
                onEdgesChange={onEdgesChange}
                onConnect={onConnect}
                onNodeClick={handleNodeClick}
                onPaneClick={handlePaneClick}
                nodeTypes={nodeTypes}
                edgeTypes={edgeTypes}
                deleteKeyCode={['Delete', 'Backspace']}
                snapToGrid={true}
                snapGrid={[GRID_SIZE, GRID_SIZE]}
                defaultViewport={{ x: 50, y: 50, zoom: 1 }}
                fitView={!isEmpty}
                fitViewOptions={{ padding: 0.2 }}
                className="bg-slate-50"
              >
                <Background
                  color="#3b82f6"
                  gap={GRID_SIZE}
                  variant={BackgroundVariant.Dots}
                  size={1.5}
                />
                <Controls />
                <MiniMap
                  nodeColor="#6366f1"
                  nodeStrokeWidth={3}
                  zoomable
                  pannable
                  position="bottom-right"
                />
              </ReactFlow>

              {/* Centered toolbar */}
              {!isEmpty && (
                <div className="absolute top-3 left-1/2 -translate-x-1/2 z-20 flex gap-2">
                  <button
                    onClick={handleAddStep}
                    className="inline-flex items-center px-3 py-1.5 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 transition-colors shadow-md"
                  >
                    <PlusIcon className="h-4 w-4 mr-1.5" />
                    Add Step
                  </button>
                </div>
              )}

              {/* Empty state overlay */}
              {isEmpty && (
                <div className="empty-state-overlay absolute inset-0 flex items-center justify-center bg-slate-50/80">
                  <div className="text-center max-w-md p-8">
                    <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-indigo-100 flex items-center justify-center">
                      <FileTextIcon className="h-8 w-8 text-indigo-600" />
                    </div>
                    <h2 className="text-xl font-semibold text-gray-900 mb-2">
                      Start Building Your Workflow
                    </h2>
                    <p className="text-gray-600 mb-6">
                      Create your first node, import an existing workflow, or paste JSON.
                    </p>
                    <div className="flex flex-col items-center gap-3">
                      <button
                        onClick={handleAddStep}
                        className="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-white bg-indigo-600 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors w-48"
                      >
                        <PlusIcon className="h-4 w-4 mr-2" />
                        Add Step
                      </button>
                      <div className="flex gap-2">
                        <button
                          onClick={() => fileInputRef.current?.click()}
                          className="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors"
                        >
                          <UploadIcon className="h-4 w-4 mr-2" />
                          Import File
                        </button>
                        <button
                          onClick={() => setShowImportModal(true)}
                          className="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors"
                        >
                          <ClipboardIcon className="h-4 w-4 mr-2" />
                          Paste JSON
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Right Sidebar */}
            <aside
              className={`${
                sidebarOpen ? 'w-96' : 'w-0'
              } transition-all duration-300 ease-out overflow-hidden border-l border-gray-200 bg-white shrink-0`}
            >
              <div className="w-96 h-full">
                <NodeDetailPanel
                  selectedNode={selectedNode}
                  onClose={handleCloseNodeView}
                  onUpdate={handleNodeUpdate}
                />
              </div>
            </aside>
          </div>

          {/* Import Modal */}
          <ImportModal
            isOpen={showImportModal}
            onClose={() => setShowImportModal(false)}
            onImport={handlePasteImport}
          />

          {/* Prompt Modal */}
          <PromptModal
            isOpen={showPromptModal}
            onClose={() => setShowPromptModal(false)}
          />
        </div>
      );
    }

    // ============================================
    // App with Provider
    // ============================================
    function App() {
      return (
        <ReactFlowProvider>
          <WorkflowCanvas />
        </ReactFlowProvider>
      );
    }

    // ============================================
    // Render
    // ============================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
